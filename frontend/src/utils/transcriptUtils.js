/***
 WARNING: these methods rely heavily on the DOM structure generated by <Transcript> component.
 This is obviously not the best approach, but not yet sure about alternatives.
 ***/

export const findActiveWordPosition = (transcriptRoot, time) => {
  const utteranceNodes = transcriptRoot.childNodes[0].childNodes;
  for (const [uid, utterance] of utteranceNodes.entries()) {
    const wordNodes = utterance.childNodes[1].childNodes;
    for (const [wid, word] of wordNodes.entries()) {
      if (word.getAttribute("data-end") > time) {
        return [uid, wid];
      }
    }
  }
  return null;
};

export const eqWordPosition = (p1, p2) => {
  if (p1 === null || p2 === null) {
    return false;
  }
  return p1[0] === p2[0] && p1[1] === p2[1];
};

export const getWordNode = (transcriptRoot, wordPosition) => {
  const utteranceNodes = transcriptRoot.childNodes[0].childNodes;
  const [uid, wid] = wordPosition;
  return utteranceNodes[uid].childNodes[1].childNodes[wid];
};

export const editWordNodeClass = (
  transcriptRoot,
  wordPosition,
  className,
  add = true
) => {
  if (wordPosition === null) {
    return;
  }
  const node = getWordNode(transcriptRoot, wordPosition);
  if (add) {
    node.classList.add(className);
  } else {
    node.classList.remove(className);
  }
};

export const scrollToWord = (transcriptRoot, wordPosition) => {
  if (wordPosition === null) {
    return;
  }
  const word = getWordNode(transcriptRoot, wordPosition);
  transcriptRoot.scrollTo({ top: word.offsetTop - 100, behavior: "auto" });
};
